using System.Threading;
using Reline.Compilation.Syntax.Nodes;
using Reline.Compilation.Diagnostics;

namespace Reline.Compilation.Syntax;

/// <summary>
/// Represents a tree of syntax nodes generated by a
/// <see cref="Parsing.Parser"/>.
/// </summary>
public sealed class SyntaxTree {

	private IReadOnlyDictionary<ISyntaxNode, ISyntaxNode?>? parents;


	
	/// <summary>
	/// The diagnostics generated during parsing.
	/// </summary>
	public ImmutableArray<Diagnostic> Diagnostics { get; }
	/// <summary>
	/// The root node of the tree.
	/// </summary>
	public ProgramSyntax Root { get; }



	internal SyntaxTree(ProgramSyntax root, ImmutableArray<Diagnostic> diagnostics) {
		Root = root;
		Diagnostics = diagnostics;
	}



	/// <summary>
	/// Gets the parent node of a specified <see cref="ISyntaxNode"/>.
	/// </summary>
	/// <param name="node">The <see cref="ISyntaxNode"/>
	/// to get the parent of.</param>
	/// <returns>The parent of <paramref name="node"/>, or <see langword="null"/>
	/// if the node is the root of the syntax tree.</returns>
	public ISyntaxNode? GetParent(ISyntaxNode node) {
		if (parents is null) {
			var initializedParents = CreateParentsDictionary(Root);
			Interlocked.CompareExchange(ref parents, initializedParents, null);
		}
		
		return parents[node];
	}
	private static IReadOnlyDictionary<ISyntaxNode, ISyntaxNode?> CreateParentsDictionary(ISyntaxNode root) {
		Dictionary<ISyntaxNode, ISyntaxNode?> result = new();
		result.Add(root, null);
		AddParentsToDictionary(result, root);
		return result;
	}
	private static void AddParentsToDictionary(IDictionary<ISyntaxNode, ISyntaxNode?> dictionary, ISyntaxNode node) {
		var children = node.GetChildren();
		foreach (var child in children) {
			dictionary.Add(child, node);
			AddParentsToDictionary(dictionary, child);
		}
	}

}
