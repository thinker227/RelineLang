using Reline.Compilation.Syntax.Nodes;
using Reline.Compilation.Diagnostics;

namespace Reline.Compilation.Syntax;

/// <summary>
/// Represents a tree of syntax nodes generated by a
/// <see cref="Parsing.Parser"/>.
/// </summary>
public sealed class SyntaxTree {

	private readonly ParentMap<ISyntaxNode> parentMap;



	/// <summary>
	/// The root node of the tree.
	/// </summary>
	public ProgramSyntax Root { get; }
	/// <summary>
	/// The diagnostics generated during parsing.
	/// </summary>
	public ImmutableArray<Diagnostic> Diagnostics { get; }



	internal SyntaxTree(ProgramSyntax root, ImmutableArray<Diagnostic> diagnostics) {
		Root = root;
		Diagnostics = diagnostics;
		parentMap = new(Root);
	}



	/// <summary>
	/// Gets the parent node of a specified <see cref="ISyntaxNode"/>.
	/// </summary>
	/// <param name="node">The <see cref="ISyntaxNode"/>
	/// to get the parent of.</param>
	/// <returns>The parent of <paramref name="node"/>, or <see langword="null"/>
	/// if the node is the root of the syntax tree.</returns>
	public ISyntaxNode? GetParent(ISyntaxNode node) =>
		parentMap.GetParent(node);
	/// <summary>
	/// Gets a parent node of a specified type of a <see cref="ISyntaxNode"/>.
	/// </summary>
	/// <typeparam name="TParent">The type of the parent node to get.</typeparam>
	/// <param name="node">The <see cref="ISyntaxNode"/> to get the parent of.</param>
	/// <returns>A <see cref="ISyntaxNode"/> of type <typeparamref name="TParent"/>,
	/// or <see langword="null"/> if none was found.</returns>
	public TParent? GetParentOfType<TParent>(ISyntaxNode node) where TParent : ISyntaxNode =>
		parentMap.GetParentOfType<TParent>(node);

}
