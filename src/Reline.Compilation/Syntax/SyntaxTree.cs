using Reline.Compilation.Syntax.Nodes;
using Reline.Compilation.Diagnostics;

namespace Reline.Compilation.Syntax;

/// <summary>
/// Represents a tree of syntax nodes generated by a
/// <see cref="Parsing.Parser"/>.
/// </summary>
public sealed class SyntaxTree {

	private readonly ParentMap<ISyntaxNode> parentMap;



	/// <summary>
	/// The root node of the tree.
	/// </summary>
	public ProgramSyntax Root { get; }
	/// <summary>
	/// The diagnostics generated during parsing.
	/// </summary>
	public ImmutableArray<Diagnostic> Diagnostics { get; }



	internal SyntaxTree(ProgramSyntax root, ImmutableArray<Diagnostic> diagnostics) {
		Root = root;
		Diagnostics = diagnostics;
		parentMap = new(Root);
	}



	/// <summary>
	/// Gets the parent node of a specified <see cref="ISyntaxNode"/>.
	/// </summary>
	/// <param name="node">The <see cref="ISyntaxNode"/>
	/// to get the parent of.</param>
	/// <returns>The parent of <paramref name="node"/>, or <see langword="null"/>
	/// if the node is the root of the syntax tree.</returns>
	public ISyntaxNode? GetParent(ISyntaxNode node) =>
		parentMap.GetParent(node);
	/// <summary>
	/// Gets an ancestor node of a specified type of an <see cref="ISyntaxNode"/>.
	/// </summary>
	/// <typeparam name="TAncestor">The type of the ancestor node to get.</typeparam>
	/// <param name="node">The <see cref="ISyntaxNode"/> to get the ancestor of.</param>
	/// <returns>An <see cref="ISyntaxNode"/> of type <typeparamref name="TAncestor"/>,
	/// or <see langword="null"/> if none was found.</returns>
	public TAncestor? GetAncestor<TAncestor>(ISyntaxNode? node) where TAncestor : ISyntaxNode => node switch {
		null => default,
		TAncestor a => a,
		_ => GetAncestor<TAncestor>(GetParent(node))
	};

	/// <summary>
	/// Gets the statements of a specified type in the tree.
	/// </summary>
	/// <typeparam name="TStatement">The type of the statements to get.</typeparam>
	/// <returns>A collection of statements of type <typeparamref name="TStatement"/>.</returns>
	public IEnumerable<TStatement> GetStatementsOfType<TStatement>() where TStatement : IStatementSyntax {
		foreach (var line in Root.Lines) {
			var statement = line.Statement;
			if (statement is TStatement s)
				yield return s;
		}
	}

}
